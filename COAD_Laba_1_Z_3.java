
/*
Задание 3. Добавить в предыдущую программу возможность занесения в стек сразу 
нескольких значений. Количество вводимых значений должно запрашиваться у 
пользователя, а сами значения можно формировать случайным образом с помощью 
функции Random (не забыть предварительно вызвать функцию Randomize). Проверить
работоспособность программы при различных количествах вводимых элементов, в том
числе – для больших значений (десятки тысяч элементов).
 */
package coad_laba_1_z_3;
import java.util.Scanner;
import java.lang.Math;
/*
Реализуем стэк в виде класса с именем Link на базе связанного списка
 */

//------------------------------Начало класса StackX----------------------------
class Link{
    public long dData;//Данные
    public Link next;//Следующий элемент в списке
//------------------------------------------------------------------------------
    public Link (long dd){//Конструктор
    dData = dd;
    }
//------------------------------------------------------------------------------
    public void displayLink(){//Вывод содержимого элемента
        System.out.print(dData + " ");
    }
}
//-------------------------Конец класса Link------------------------------------
//--------------------------Класс LinkList--------------------------------------
    class LinkList{
        private Link first;//Ссылка на первый элемент в списке
//------------------------------------------------------------------------------
    public LinkList(){//Конструктор
        first = null; //Список пока не содержит элементов
    }
//------------------------------------------------------------------------------
    public boolean isEmpty (){//true если список пуст
        return (first == null);
    }
//------------------------------------------------------------------------------
    public void insertFirst(int dd){ // Вставка элемента в начало списка
        long past;
        for (int i =0; i < dd; i++){
            past = (long)(Math.random()*200-100);
            Link newLink = new Link (past);
            newLink.next=first; //newLink - старое значение first
            first = newLink; //first - newlink
            System.out.println("В стэк добавлен элемент " + past);
        }
    }
//------------------------------------------------------------------------------
    public long deleteFirst(){//Удаление первого элемента (предполагается, что список не пустой!!!)
        Link temp = first;//Сохранение ссылки
        first = first.next;//Удаление: first - ссылка на второй элемент
        return temp.dData;//Возвращаем данные удаленного элемента 
    }
//------------------------------------------------------------------------------
    public void displayList(){
        Link current = first; // От начала списка
        while (current != null){//Перемещение доконца списка
            current.displayLink();//Вывод данных
            current = current.next;//Переход к следущему элементу
        }
        System.out.println("");
    }
}
//----------------------------Конец класса LinkList-------------------------------
//----------------------------Класс LinkStack-------------------------------------     
    class LinkStack{
        private LinkList theList;
//--------------------------------------------------------------
        public LinkStack(){ // Конструктор
            theList = new LinkList();
        }
//--------------------------------------------------------------
        public void push(int j){ // Размещение элемента на вершине стека
            theList.insertFirst(j);
        }
//--------------------------------------------------------------
        public long pop(){ // Извлечение элемента с вершины стека
            return theList.deleteFirst();
        }
//--------------------------------------------------------------
        public boolean isEmpty(){ // true, если стек пуст
            return ( theList.isEmpty() );
        }
//--------------------------------------------------------------
        public void displayStack(){
            System.out.print("Stack (top-->bottom): ");
            theList.displayList();
        }
    }
//---------------------------- Конец класса LinkStack ----------------------------------

public class COAD_Laba_1_Z_3 {

    /*
    Необходимо запонить стек. Т.К. он пуст!!!!!!!!!!!!!!!
    Первое действие - 2 ВСТАВКА!!!!!!!!!!!!!!!!!!
     */
public static void main(String[] args) {
        // TODO code application logic here
        int UserInput;
        int UserInpuForPush;
        Scanner input = new Scanner (System.in);
        LinkStack theStack = new LinkStack();//Создание нового стэк
        
//---------------------------Диалог с пользователем-----------------------------
        while (true){
            System.out.println("Какую операцию выполнить? 1 - Удаление ; 2 - Вставка N элементов; 3 - Вывод на экран;");
            switch (UserInput=input.nextInt()){
                case 1:
                    System.out.println("Удален элемент из top "+theStack.pop());
                    break;
                case 2:
                    System.out.println("Введите количество элементов для добавления в стэк");
                    UserInpuForPush = input.nextInt();
                    theStack.push(UserInpuForPush);
                    break;
                case 3:
                    System.out.println("Стек содержит ");
                    theStack.displayStack();
                    break;
                default:
                    break;           
            }        
        System.out.println("");
        }
    }
}
/* ИТОГИ ВСТАВКИ 100 000 ЭЛЕМЕНТОВ. ВЫВОД:

Вставка и удаление в начале связанного списка выполняются очень быстро. 
Операция сводится к изменению одной или двух ссылок, выполняемому за время O(1).
Поиск, удаление и вставка рядом с конкретным элементом требует перебора
в среднем половины элементов списка, для которого необходимо O(N) сравнений.
У массива эти операции тоже выполняются за время O(N), но связанный список все
равно работает быстрее, потому что он не требует перемещения элементов при 
вставке или удалении. Повышение эффективности может быть весьма значительным,
особенно если копирование занимает существенно больше времени, чем сравнение.
Другое важное преимущество связанных списков перед массивами заключается в том,
что связанный список всегда использует ровно столько памяти, сколько
необходимо, и может расширяться вплоть до всей доступной памяти. 
*/